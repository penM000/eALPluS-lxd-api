
import psutil
import os
import socket
import netifaces as ni
import random
from typing import List
from ipaddress import (
    ip_interface, ip_address)


from .lxd_client import client
from .general.async_wrap import async_wrap


async def create_network(name: str, network_type: str = "bridge") -> None:
    if not client.networks.exists(name):
        async_execute = async_wrap(client.networks.create)
        await async_execute(
            name,
            description=f"Network automatically generated by ealplus for {name}.",
            type=network_type,
            config={
                "ipv4.address": "auto",
                "ipv4.nat": "true",
                "ipv6.address": "auto",
                "ipv6.nat": "true"
            }
        )


def get_used_port() -> List[int]:
    """
    現在利用中のportと割り当て済みのport一覧作成
    """
    used_ports = [int(conn.laddr.port) for conn in psutil.net_connections()
                  if conn.status == 'LISTEN']
    for machine in client.containers.all():
        for key in machine.devices:
            if "type" in machine.devices[key]:
                if machine.devices[key]["type"] == "proxy":
                    used_ports.append(
                        int(machine.devices[key]["listen"].split(":")[-1]))

    for machine in client.virtual_machines.all():
        for key in machine.devices:
            if "type" in machine.devices[key]:
                if machine.devices[key]["type"] == "proxy":
                    used_ports.append(
                        int(machine.devices[key]["listen"].split(":")[-1]))
    used_ports = sorted(set(used_ports))
    return used_ports


def check_port_available(port: int) -> bool:
    used_ports = get_used_port()
    if (port in used_ports):
        return False
    else:
        return True


def scan_available_port(start_port: int, mode: str = "random") -> int:
    """
    概要:
        このAPIが動作しているコンピューターの空きポートを検索する関数
    動作モード:
        random: ポート割当はランダム
        countup: 最初からきれいにポートを割り当てる
    返り値:
        割当可能なポート番号(int)
    """
    port_offset = 0
    used_ports = get_used_port()
    available_port_count = (65535 - start_port) - len(
        [1 for x in used_ports if x >= start_port])
    if available_port_count < 10:
        raise Exception("利用可能なport上限を超えました")
    while True:
        if mode == "random":
            port_candidate = random.randint(start_port, 65535)
        elif mode == "countup":
            port_candidate = start_port + port_offset
        if port_candidate in used_ports:
            port_offset += 1
            continue
        else:
            return port_candidate


def get_ip_address(client_ip: str = "0.0.0.0") -> List[str]:
    """
    概要:
        このAPIが動作しているIPアドレスから、
        引数で渡されたIPアドレスと同一ネットワーク上のものを検索する。
    返り値:
        ipアドレスのリスト
    """
    if os.name == "nt":
        # Windows
        return socket.gethostbyname_ex(socket.gethostname())[2]
        pass
    else:
        # それ以外
        result = []
        address_list = psutil.net_if_addrs()
        for nic in address_list.keys():
            ni.ifaddresses(nic)
            try:
                ip_adress = ni.ifaddresses(nic)[ni.AF_INET][0]['addr']
                subnet = ni.ifaddresses(nic)[ni.AF_INET][0]['netmask']
                ip = ip_interface(f"{ip_adress}/{subnet}")
                if ip_address(client_ip) in ip.network:
                    return [str(ip.ip)]
                if ip_adress not in ["127.0.0.1"]:
                    result.append(str(ip_adress))
            except KeyError as err:
                # print(err)
                err
                pass
        return result
